#!/usr/bin/env perl
# SPDX-License-Identifier: MIT
# MIT License
#
# Copyright (c) 2020 Christoph GÃ¶ttschkes
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

=head1 NAME

url-hint - Extension for URxvt which brings a hint mode to follow URLs

=head1 DESCRIPTION

This B<URxvt> extension adds a hint mode to the terminal emulator, which
highlights URLs.
A pattern is presented for each URL, which can be used to open the URL using a
user defined application.
B<url-hint> is inspired by the hint mode of vimperator (or similar
browser extensions).

To enter the hint mode, create a B<URxvt> B<keysym> resource which invokes
the B<url-hint:hint> action.
Once the hint mode is activated (by pressing the B<keysym>), one can exit it
again by pressing either the key specified by the B<url-hint.exit-keysym>
resource, or the Escape key.
Use the B<xev> utility to find the name of the desired keysym.

B<NOTE>: For B<url-hint.exit-keysym>, the keysym description used by B<URxvt>
itself (using the 'M-' or 'C-' prefix) is not supported.
Please see the description of the B<XStringToKeysym> function for further
details.

The letters used to create the patterns can be defined by using the
B<url-hint.hint-chars> resource.
Each character of the given string will be used to create the patterns.
The length of each pattern depends on the number of visible URLs on the screen.
If the screen changes (because more output is generated by a program, or the
screen is scrolled-back), the generated patterns might change.

While the pattern is typed (and therefore not yet fully provided), the already
provided part is not presented on the screen directly.
But the pattern for each URL, which starts with the given input, changes its
font to indicate which part of the pattern has already been provided.
If the screen changes, the partially provided pattern might be reset.

The application which is used to open the URL is configured by the resource
B<url-hint.launcher>.

The B<url-hint:hint> action and B<url-hint.launcher> resource support a
C<.E<lt>numberE<gt>>> suffix.
The keysym defined for a B<url-hint:hint> with a specific suffix uses the launcher
with the same suffix.
This enables one to have multiple different keysyms for different applications.

=head1 INSTALLATION

B<URxvt> looks into multiple different directories when searching for extensions.
These can be configured using the B<URxvt> resource B<perl-lib>.
Please see L<urxvt(1)>.

If this extension should be installed into the users home directory, the
provided B<Makefile> can be used.
Simply run C<make install-home> as the desired user.
This installs the extension and the man page into the correct places in the users
home directory.
B<URxvt> should find the extension without the need to configure the B<perl-lib>
resource.

=head1 RESOURCES

=over 4

=item B<launcher>[I<.E<lt>numberE<gt>>]

Application which should be used to open URLs. The URL is always appended as an
addition argument to the given launcher.
If the arguments need be rearrange, wrap the application into a call to C</bin/sh>.
See the examples.

=item B<hint-chars>

Valid characters for the generated patterns.

=item B<exit-keysym>

Key to exit the hint mode.

=back

=head1 ACTIONS

=over 4

=item B<hint>[I<.E<lt>numberE<gt>>]

Starts the hint mode and uses the B<url-hint.launcher> resource with the same
I<.E<lt>numberE<gt>> suffix to launch the chosen URL.

=back

=head1 EXAMPLE RESOURCE

The following shows an example resource configuration with the default values
for each resource entry:

    URxvt.url-hint.launcher: /usr/bin/env xdg-open
    URxvt.url-hint.hint-chars: asdfjk
    URxvt.url-hint.exit-keysym: q

Enable the extension and configure a keysym for the B<url-hint:hint> action:

    URxvt.perl-ext-common: default,url-hint,...
    URxvt.keysym.M-f: url-hint:hint

The following shows a configuration, for wich C<M-f> launches C<xdg-open>, and
C<M-F> copies the URL into the clipboard:

    URxvt.url-hint.launcher.1: xdg-open
    URxvt.url-hint.launcher.2: /bin/sh -c 'printf "%s" "$1" |xclip' url-hint.launcher.2
    URxvt.keysym.M-f: url-hint:hint.1
    URxvt.keysym.M-F: url-hint:hint.2

The second launcher starts a new shell and executes C<printf "%s" "$1" |xclip> in it.
The string C<url-hint.launcher.2> would be accessible as C<$0> in the shell (the name of the command).
B<url-hint> appends the URL to the launcher call, which will therefore be accessible in the shell
script via C<$1>.

=head1 DEPENDENCIES

This extensions depends on the following perl modules, which can be downloaded
from CPAN, or using the package manager of your Linux distribution:

=over 4

=item L<B<Regexp::Common>|https://metacpan.org/pod/Regexp::Common>

Regular expression to match URIs.

=item L<B<Algorithm::Combinatorics>|https://metacpan.org/pod/Algorithm::Combinatorics>

Efficient generation of combinatorial sequences.

=back

=head1 SEE ALSO

L<urxvt(1)>, L<urxvtperl(3)>, L<xrdb(1)>

=head1 COPYRIGHT and LICENSE

This software is Copyright (c) 2020, Christoph GE<ouml>ttschkes.

This is free software; you can redistribute it and/or modify it under the terms
of the MIT license.

=cut

use strict;
use warnings;

use urxvt;

use List::Util qw(min max);
use POSIX;
use Text::ParseWords qw(parse_line);

use Algorithm::Combinatorics qw(variations_with_repetition);
use Regexp::Common qw(URI);

my $DEFAULT_LAUNCHER_APPLICATION = "/usr/bin/env xdg-open";

sub config_resource {
  my ( $self, $key, $default ) = @_;
  if ( defined( my $value = $self->x_resource("%.$key") ) ) {
    return $self->locale_decode($value);
  }
  return $default;
}

sub get_launcher {
  my ( $self, $idx ) = @_;
  $idx = "" unless ( defined($idx) );
  $self->{launchers} = {} unless ( defined( $self->{launchers} ) );
  unless ( defined( $self->{launchers}->{$idx} ) ) {
    my $key = "launcher" . ( ( $idx eq "" ) ? "" : "." ) . $idx;
    $self->{launchers}->{$idx} = $self->config_resource( $key, undef );
    unless ( defined( $self->{launchers}->{$idx} ) ) {
      urxvt::warn( "url-hint: launcher." . $idx . " not defined\n" );
      $self->{launchers}->{$idx} = $DEFAULT_LAUNCHER_APPLICATION;
    }
  }
  return $self->{launchers}->{$idx};
}

sub on_start {
  my ($self) = @_;

  @{ $self->{hint_chars} } = split( //, $self->config_resource( "hint-chars", "asdfjkl" ) );
  $self->{exit_keysym} = $self->config_resource( "exit-keysym", "q" );
  $self->{backspace}   = $self->XStringToKeysym("BackSpace");
  $self->{escape}      = $self->XStringToKeysym("Escape");
  $self->{pressed}     = "";
  @{ $self->{matches} } = ();

  $self->{rend_matched}   = urxvt::OVERLAY_RSTYLE | urxvt::RS_Uline | urxvt::RS_Bold;
  $self->{rend_unmatched} = urxvt::OVERLAY_RSTYLE;
  $self->{exit_keysym}    = $self->XStringToKeysym( $self->{exit_keysym} );
  return 1;
}

sub on_destroy {
  my $self = shift;
  $self->exit_hint_mode;
  return 1;
}

BEGIN { *on_reset = \&on_refresh_end; }

sub on_refresh_end {
  my $self = shift;
  $self->update if ( defined( $self->{overlay} ) );
  return 1;
}

BEGIN { *on_view_change = \&on_line_update; }

sub on_line_update {
  my $self = shift;
  $self->{pressed} = "";
  $self->update if ( defined( $self->{overlay} ) );
  return 1;
}

sub on_action {
  my ( $self, $action ) = @_;
  if ( $action eq "hint" ) {
    $self->{active_launcher} = $self->get_launcher("");
    $self->enter_hint_mode;
  }
  elsif ( $action =~ /^hint.([0-9]+)$/x ) {
    $self->{active_launcher} = $self->get_launcher($1);
    $self->enter_hint_mode;
  }
  else {
    urxvt::warn( "url-hint: " . $action . ": unknown action\n" );
    return 0;
  }
  return 1;
}

sub create_hint_overlay {
  my ( $self, $ncol, $force ) = @_;
  $ncol  ||= $self->ncol;
  $force ||= 0;
  if ( $force || !defined( $self->{overlay} ) ) {
    my $text = sprintf( "url-hint mode: press '%s' to exit",
      $self->XKeysymToString( $self->{exit_keysym} ) );
    if ( defined( $self->{overlay} ) ) {
      $self->{overlay}->hide;
      delete $self->{overlay};
    }
    $self->{overlay} = $self->overlay( 0, -1, $ncol, 1, urxvt::OVERLAY_RSTYLE, 0 );
    $self->{overlay}->set( 0, 0, $self->special_encode($text) );
  }
  return;
}

sub on_resize_all_windows {
  my ( $self, $new_width, $new_height ) = @_;
  if ( defined( $self->{overlay} ) ) {
    $self->create_hint_overlay( $new_width, 1 );
  }
  return 0;
}

sub calc_pattern_length {
  my ( $chars, $n_matches ) = @_;
  return max( 1, ceil( log($n_matches) / log( scalar @{$chars} ) ) );
}

sub create_pattern_iter {
  my ( $chars, $len ) = @_;
  return variations_with_repetition( $chars, $len );
}

sub startswith {
  my ( $str, $substr ) = @_;
  return 0 if ( length($substr) == 0 );
  return ( rindex( $str, $substr, 0 ) == 0 );
}

sub update {
  my ($self) = @_;

  for my $match ( @{ $self->{matches} } ) {
    if ( defined( $match->{overlay} ) ) {
      $match->{overlay}->hide;
      delete $match->{overlay};
    }
  }
  @{ $self->{matches} } = ();

  my $view_start = $self->view_start;
  my $row        = $view_start;
  my $end        = $view_start + $self->nrow;
  while ( $row < $end ) {
    my $line = $self->line($row)
      or last;
    my $text = $line->t;

    while ( $text =~ /$RE{URI}{-keep}/gx ) {
      my $url = substr( $text, $-[0], $+[0] - $-[0] );
      my ( $row_coord, $col_coord ) = $line->coord_of( $-[0] );
      if ( $row_coord >= $view_start && $row_coord < $end ) {
        push @{ $self->{matches} },
          {
          hint     => "",
          offset_x => $col_coord,
          offset_y => $row_coord - $view_start,
          overlay  => undef,
          url      => $url,
          };
      }
    }

    $row = $line->end + 1;
  }

  my $n_matches = scalar @{ $self->{matches} };
  if ( $n_matches > 0 ) {
    my $hint_len     = calc_pattern_length( \@{ $self->{hint_chars} }, $n_matches );
    my $iter         = create_pattern_iter( \@{ $self->{hint_chars} }, $hint_len );
    my @pressed_rend = ();
    @pressed_rend =
      map { $self->{rend_matched} } ( 1 .. length( $self->{pressed} ) )
      if ( length( $self->{pressed} ) > 0 );
    for my $match ( @{ $self->{matches} } ) {
      my $hint         = join( '', @{ $iter->next } );
      my $hint_enc     = $self->special_encode($hint);
      my $hint_enc_len = $self->strwidth($hint);
      my $x            = max( 0, $match->{offset_x} - $hint_enc_len );
      my $y            = $match->{offset_y};
      $match->{hint} = $hint;
      $match->{overlay} =
        $self->overlay( $x, $y, $hint_enc_len, 1, $self->{rend_unmatched}, 0 );
      if ( startswith( $match->{hint}, $self->{pressed} ) ) {
        $match->{overlay}->set( 0, 0, $hint_enc, \@pressed_rend );
      }
      else {
        $match->{overlay}->set( 0, 0, $hint_enc );
      }
    }
  }

  return 1;
}

sub enter_hint_mode {
  my ($self) = @_;

  return 1 if ( defined( $self->{overlay} ) );
  $self->{pressed} = "";
  $self->update;

  if ( scalar( @{ $self->{matches} } ) == 0 ) {
    $self->exit_hint_mode;
  }
  else {
    $self->create_hint_overlay;
    $self->enable( key_press => \&key_pressed );
  }

  return 1;
}

sub exit_hint_mode {
  my ($self) = @_;
  if ( defined( $self->{overlay} ) ) {
    $self->{overlay}->hide;
    delete $self->{overlay};
  }
  for my $match ( @{ $self->{matches} } ) {
    if ( defined( $match->{overlay} ) ) {
      $match->{overlay}->hide;
      delete $match->{overlay};
    }
  }
  $self->disable("key_press");
  @{ $self->{matches} } = ();
  $self->{pressed} = "";
  delete $self->{active_launcher};
  return 1;
}

sub key_pressed {
  my ( $self, $event, $keysym, $string ) = @_;
  if ( $keysym == $self->{exit_keysym} || $keysym == $self->{escape} ) {
    $self->exit_hint_mode;
  }
  elsif ( $keysym == $self->{backspace} ) {
    if ( length( $self->{pressed} ) > 0 ) {
      $self->{pressed} = substr( $self->{pressed}, 0, -1 );
    }
  }
  elsif ( grep { $_ eq $string } @{ $self->{hint_chars} } ) {
    $self->{pressed} .= $string;
    $self->update;
    if ( length( $self->{pressed} ) == length( $self->{matches}[0]->{hint} ) ) {
      for my $match ( @{ $self->{matches} } ) {
        if ( $self->{pressed} eq $match->{hint} ) {
          my @exec = parse_line( '\s+', 0, $self->{active_launcher} );
          push @exec, $match->{url};
          $self->exec_async(@exec);
          last;
        }
      }
      $self->exit_hint_mode;
    }
  }
  return 1;
}

1;
