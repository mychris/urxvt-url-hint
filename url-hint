#!/usr/bin/env perl
# SPDX-License-Identifier: MIT
# MIT License
#
# Copyright (c) 2020 Christoph GÃ¶ttschkes
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

=head1 NAME

url-hint - Extension for URxvt which brings a hint mode to follow URLs

=head1 DESCRIPTION

This B<URxvt> extension adds a hint mode to the terminal emulator, which
highlights URLs.
A pattern is presented for each URL, which can be used to open the URL using a
user defined application.
B<url-hint> is inspired by the hint mode of vimperator (or similar
browser extensions).

To enter the hint mode, create a B<URxvt> I<keysym> resource which invokes
the I<url-hint:hint> action.
Once the hint mode is activated, you can exit it again by pressing either the
key specified by the I<url-hint.exit-keysym> resource, or the Escape key.
Use the B<xev> utility to find the name of the desired keysym.

B<NOTE>: For I<url-hint.exit-keysym>, the keysym description used by B<URxvt>
itself (using the 'M-' or 'C-' prefix) is not supported.
Please see the description of the B<XStringToKeysym> function for further
details.

The letters used to create the patterns can be defined by using the
I<url-hint.hint-chars> resource.
Each character of the given string will be used to create the patterns.
The length of each pattern depends on the number of visible URLs on the screen.
If the screen changes (because more output is generated by a program, or the
screen is scrolled-back), the generated patterns might change.

While the pattern is typed (and therefore not yet fully provided), the already
provided part is not presented on the screen directly.
But the pattern for each URL, which starts with the given input, changes its
font to indicate which part of the pattern has already been provided.
If the screen changes, the partially provided pattern might be reset.

The application which is used to open the URL is configured by the resource
I<url-hint.launcher>.

=head1 RESOURCES

=over 4

=item I<url-hint:hint> action

Action which enters the hint mode.

=item I<url-hint.launcher>

Application which should be used to open the chosen URL.

=item I<hint-chars>

Characters which are used to generate the pattern.

=item I<exit-keysym>

Key to exit the hint mode.

=back

=head1 EXAMPLE RESOURCE

The following shows an example resource configuration with the default values
for each resource entry:

    URxvt.url-hint.launcher: /usr/bin/xdg-open
    URxvt.url-hint.hint-chars: asdfjk
    URxvt.url-hint.exit-keysym: q

Enable the extension and configure a keysym for the I<url-hint:hint> action:

    URxvt.perl-ext-common: default,url-hint,...
    URxvt.keysym.M-f: url-hint:hint

=head1 DEPENDENCIES

This extensions depends on the following perl modules, which can be downloaded
from CPAN, or using the package manager of your Linux distribution:

=over 4

=item B<Regexp::Common>

Regular expression to match URIs.

=item B<Algorithm::Combinatorics>

Efficient generation of combinatorial sequences.

=back

=head1 COPYRIGHT and LICENSE

This software is Copyright (c) 2020, Christoph GE<ouml>ttschkes.

This is free software; you can redistribute it and/or modify it under the terms
of the MIT license.

=cut

use strict;
use warnings;

use urxvt;

use List::Util qw(min max);
use POSIX;

use Algorithm::Combinatorics qw(variations_with_repetition);
use Regexp::Common qw(URI);

sub config_resource {
  my ( $self, $key, $default ) = @_;
  if ( defined( my $value = $self->x_resource("%.$key") ) ) {
    return $self->locale_decode($value);
  }
  return $default;
}

sub on_start {
  my ($self) = @_;

  $self->{launcher} = $self->config_resource( "launcher", "/usr/bin/xdg-open" );
  @{ $self->{hint_chars} } =
    split( //, $self->config_resource( "hint-chars", "asdfjkl" ) );
  $self->{exit_keysym} = $self->config_resource( "exit-keysym", "q" );
  $self->{backspace}   = $self->XStringToKeysym("BackSpace");
  $self->{escape}      = $self->XStringToKeysym("Escape");
  $self->{pressed}     = "";
  @{ $self->{matches} } = ();

  $self->{rend_matched}   = urxvt::OVERLAY_RSTYLE | urxvt::RS_Uline | urxvt::RS_Bold;
  $self->{rend_unmatched} = urxvt::OVERLAY_RSTYLE;
  $self->{exit_keysym}    = $self->XStringToKeysym( $self->{exit_keysym} );
  return 1;
}

sub on_destroy {
  my $self = shift;
  $self->exit_hint_mode;
  return 1;
}

BEGIN { *on_reset = \&on_refresh_end; }

sub on_refresh_end {
  my $self = shift;
  $self->update if ( defined( $self->{overlay} ) );
  return 1;
}

BEGIN { *on_view_change = \&on_line_update; }

sub on_line_update {
  my $self = shift;
  $self->{pressed} = "";
  $self->update if ( defined( $self->{overlay} ) );
  return 1;
}

sub on_action {
  my ( $self, $action ) = @_;
  $self->enter_hint_mode if ( $action eq "hint" );
  return 1;
}

sub calc_pattern_length {
  my ( $chars, $n_matches ) = @_;
  return max( 1, ceil( log($n_matches) / log( scalar @{$chars} ) ) );
}

sub create_pattern_iter {
  my ( $chars, $len ) = @_;
  return variations_with_repetition( $chars, $len );
}

sub startswith {
  my ( $str, $substr ) = @_;
  return 0 if ( length($substr) == 0 );
  return ( rindex( $str, $substr, 0 ) == 0 );
}

sub update {
  my ($self) = @_;

  for my $match ( @{ $self->{matches} } ) {
    if ( defined( $match->{overlay} ) ) {
      $match->{overlay}->hide;
      delete $match->{overlay};
    }
  }
  @{ $self->{matches} } = ();

  my $view_start = $self->view_start;
  my $row        = $view_start;
  my $end        = $view_start + $self->nrow;
  while ( $row < $end ) {
    my $line = $self->line($row)
      or last;
    my $text = $line->t;

    while ( $text =~ /$RE{URI}{-keep}/gx ) {
      my $url = substr( $text, $-[0], $+[0] - $-[0] );
      my ( $row_coord, $col_coord ) = $line->coord_of( $-[0] );
      if ( $row_coord >= $view_start && $row_coord < $end ) {
        push @{ $self->{matches} },
          {
          hint     => "",
          offset_x => $col_coord,
          offset_y => $row_coord - $view_start,
          overlay  => undef,
          url      => $url,
          };
      }
    }

    $row = $line->end + 1;
  }

  my $n_matches = scalar @{ $self->{matches} };
  if ( $n_matches > 0 ) {
    my $hint_len     = calc_pattern_length( \@{ $self->{hint_chars} }, $n_matches );
    my $iter         = create_pattern_iter( \@{ $self->{hint_chars} }, $hint_len );
    my @pressed_rend = ();
    @pressed_rend =
      map { $self->{rend_matched} } ( 1 .. length( $self->{pressed} ) )
      if ( length( $self->{pressed} ) > 0 );
    for my $match ( @{ $self->{matches} } ) {
      my $hint     = join( '', @{ $iter->next } );
      my $hint_enc = $self->special_encode($hint);
      my $x        = max( 0, $match->{offset_x} - $hint_len );
      my $y        = $match->{offset_y};
      $match->{hint} = $hint;
      $match->{overlay} =
        $self->overlay( $x, $y, $hint_len, 1, $self->{rend_unmatched}, 0 );
      if ( startswith( $match->{hint}, $self->{pressed} ) ) {
        $match->{overlay}->set( 0, 0, $hint_enc, \@pressed_rend );
      }
      else {
        $match->{overlay}->set( 0, 0, $hint_enc );
      }
    }
  }

  return 1;
}

sub enter_hint_mode {
  my ($self) = @_;

  return 1 if ( defined( $self->{overlay} ) );
  $self->{pressed} = "";
  $self->update;

  if ( scalar( @{ $self->{matches} } ) == 0 ) {
    $self->exit_hint_mode;
  }
  else {
    my $text = sprintf( "url-hint mode: press '%s' to exit",
      $self->XKeysymToString( $self->{exit_keysym} ) );
    $self->{overlay} = $self->overlay( 0, -1, $self->ncol, 1, urxvt::OVERLAY_RSTYLE, 0 );
    $self->{overlay}->set( 0, 0, $self->special_encode($text) );
    $self->enable( key_press => \&key_pressed );
  }

  return 1;
}

sub exit_hint_mode {
  my ($self) = @_;

  if ( defined( $self->{overlay} ) ) {
    $self->{overlay}->hide;
    delete $self->{overlay};
  }
  for my $match ( @{ $self->{matches} } ) {
    if ( defined( $match->{overlay} ) ) {
      $match->{overlay}->hide;
      delete $match->{overlay};
    }
  }
  $self->disable("key_press");
  @{ $self->{matches} } = ();
  $self->{pressed} = "";

  return 1;
}

sub key_pressed {
  my ( $self, $event, $keysym, $string ) = @_;

  if ( $keysym == $self->{exit_keysym} || $keysym == $self->{escape} ) {
    $self->exit_hint_mode;
  }
  elsif ( $keysym == $self->{backspace} ) {
    if ( length( $self->{pressed} ) > 0 ) {
      $self->{pressed} = substr( $self->{pressed}, 0, -1 );
    }
  }
  elsif ( grep { $_ eq $string } @{ $self->{hint_chars} } ) {
    $self->{pressed} .= $string;
    $self->update;
    if ( length( $self->{pressed} ) == length( $self->{matches}[0]->{hint} ) ) {
      for my $match ( @{ $self->{matches} } ) {
        if ( $self->{pressed} eq $match->{hint} ) {
          $self->exec_async( ( $self->{launcher}, $match->{url} ) );
          last;
        }
      }
      $self->exit_hint_mode;
    }
  }

  return 1;
}

1;
